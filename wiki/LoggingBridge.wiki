#summary Describes the GuiceBox logging bridge and how to use it.

= Introduction =

GuiceBox's logging bridge (`Log`) allows you to easily switch between different logging libraries (for example, at different phases of development, testing, or production). There is a default logging implementation called ConsoleLogger which simply logs to `stdout` and `stderr`.

= How to Use =

`Log` solves one of the common API problems of many logging libraries, namely that in order to avoid the performance overhead of building multi-part log messages, you are forced to call something like `isLoggable()` before each and every potentially filtered log statement. Instead of:
{{{
if(isLoggable(INFO)) log.info("Found " + count + " instances in " + fileCount + " files");
}}}
...you can do this:
{{{
log.info("Found", count, "instances in", fileCount, "files");
}}}

This way you don't pay the performance penalty of concatenating strings unless the log level is INFO or below. (Performance is further improved by using `StringBuilder` instead of normal string concatenation.)

There are several ways to use the logging bridge, described below.

== Use the default logger ==
In most cases, this is the easy and practical choice. All you need is a static import at the top of your Java file to access the default logger, `log`. It's easy to switch to a class logger later if you need (see below).
{{{
import static org.codeshark.guicebox.Log;

public class MyClass
{
    public void myMethod()
    {
        log.info("Hello World!");
    }
}
}}}

== Use a named logger ==

Some logging libraries allow different logging levels to be set for each logging _channels_, which are identified by a name. Use the `Log.forName(String)` method to create these.
{{{
import org.codeshark.guicebox.Log;

public class MyClass
{
    private static final Log alert = Log.forName("emailalert");
    
    public void myMethod()
    {
        alert.error("System error - please check!");
    }
}
}}}

== Use a class logger ==

Often, you will want to have channels for each or some of your classes. Use `Log.forClass()` to create a logger with the fully-qualified name of your class as the channel name.
{{{
import org.codeshark.guicebox.Log;

public class MyClass
{
    private static final Log log = Log.forClass();
    
    public void myMethod()
    {
        log.info("Hello World!");
    }
}
}}}

= Configuration =

If you are happy to use the default ConsoleLogger implementation, you don't have to do any configuration. To use another implementation, simply include the implementation's module when creating the Guice Injector. For example, to bind to Log4j:
{{{
final Injector injector = Guice.createInjector(new Log4jModule());
}}}
This will bind the `Logger` interface to `Log4jLogger`.

== Other Options ==

Besides the logger implementation itself, you can also configure various options for the LoggingBridge API via properties (see PropertiesModule and CommandLineModule).

=== Log Time ===

Set `org.codeshark.guicebox.LogTime` to a `SimpleDateFormat`-compatible datetime format (eg. `HH:mm:ss.SSS`) to prefix each log message with a time stamp.

=== Thread Name ===

Set `org.codeshark.guicebox.LogThread` to `true` to prefix each log message with the name of the thread that emitted it.

=== Link to Source ===

Set `org.codeshark.guicebox.LogSource` to `true` to prefix each log message with the class and line number of the source code that emitted it. (In most IDEs this will link directly to your source code.)

= Creating a Logger Implementation =

GuiceBox (at time of writing) includes bridges to the following logging libraries:
 * ConsoleLogger (default)
 * [http://logging.apache.org/log4j/1.2/ Log4j]

To create a bridge to your favourite logging library, just create a class to implement `org.codeshark.guicebox.Logger` and a Guice Module to bind it to the `Logger` interface. You will also  need to request static injection to `Log.class`, as shown below.
{{{
public class MyLoggerModule extends AbstractModule
{
    protected void configure()
    {
        requestStaticInjection(Log.class);
        bind(Logger.class).to(MyLogger.class);
    }
}
}}}



